Merge Intervals
시작과 끝으로 주어진 배열이 존재해. 이 배열들을 하나의 Interval로 합칠 수 있다면 합쳐라.
[1, 5], [3, 7], [10, 15], [8, 16]

이것 또한 우선 그림을 통해서 직관을 얻어볼 수 있겠지.
[1, 7], [8, 16]까지 답을 구하면 되겠다.

그러면 이 직관을 이용해서 어떻게 알고리즘을 짤 건지 고민해봐야겠지.

첫 번째 방법은 하나씩 써보는거지.
1 ~ 5 그리고 3 ~ 7까지 왔으니까, 바로 merge를 시키는거지.
그리고 다음 interval과 비교를 해서 겹치는 구간이 있다면 merge 없다면, Interval로 나두고 다음 Interval로 기존에 있던 interval과 비교를 해서 합치는 과정을 거치는거지.
그래서 이 방법은 새로운 merge를 할때 마다 기존의 interval과 비교를 해야하기에, O(n^2)이 필요할 것이다.

더 개선된 방법이 필요하다. 생각해볼 수 있고.
O(nlogn)을 시도해볼수 있겠지.
그러면, 한 번 sorting을 해보고 문제 풀이를 시도해볼까 생각해볼 수 있어.

Interval의 시작점을 기준으로 정렬을 해보는거지.
이제 Interval들은 시작점을 기준으로 정렬이 되어있으니, 앞의 Interval의 끝점과 다음 Interval의 시작점을 비교해서 끝점이 시작점보다 크다면, 둘을 merge할 수 있는거지.
그리고 그렇지 않다면, 다음 Interval의 끝부분으로 바꾸고, 그 다음 interval의 시작점으로 또 바꾸면 되겠지.

merge의 경우 time Complexity가 O(n)
sorting의 경우 O(nlogn)
 
[이 문제를 통해서 하고 싶은 말]
특정 문제의 경우 O(nlogn)을 감수하고 문제를 푸는 것 또한 필요한 경우가 존재할 수 있다.
그림을 통해서 직관을 얻어보자.
