sortColors(Dutch flag problem)

Counting을 통해서 계산하는 정렬. countingMethod 말고 in-place Swap을 활용해서 문제를 풀어봐라.

O(n)의 시간복잡도로 정렬 + 0, 1, 2로만 구성된 배열 + in-place swap

quickSort를 사용해볼 수 있어.
quickSort가 중요한 이유는 pivot, partitioning을 뽑을 수 있다.

두 개의 index를 잡고 분홍이 가리키는 숫자를 pivot과 비교하면서 pivot보다 작으면 주황색 포인터와 교환하고 업데이트하는 방식으로 quickSort를 implementation했어.
그랬을때 결과로, 주황색 포인터가 가리키는 왼쪽에대해서는 모든 숫자가 pivot보다 작은숫자로 채워지게된다.

이와 똑같은 approach를 O(n)의 시간복잡도로 정렬 + 0, 1, 2로만 구성된 배열 + in-place swap 문제에 적용할 수 있어.

주황색 포인터와 분홍색포인터를 설정하고 이 분홍색 포인터는 0을 만날때 마다 주황색 포인터와 swap을 해주고 주황색 포인터는 0을 받게되면 한 칸 앞으로 옮겨질수있어.
여기서 중요한데, 0만 저장하는 포인터 하나만 생각할 필요 없이, 2만 저장하는 포인터를 반대편에 새로 설정할 수 있어. 분홍색 포인터가 2를 만나게되는데 2가 가리키는 포인터와 swap을 해주게하고 초록색 포인터가 2를 받게되면 한 칸 왼쪽으로 옮겨줄 수 있는거지.

그런데, 여기서 초록색 포인터의 우측에는 2라는 숫자만 올 것인데 초록색 포인터로부터 스왑된 분홍색 포인터의 값은 0 또는 1의 숫자가 오게된다. 그러면 여기서 분홍색 포인터가 다시 0인지 확인하고 0이면 주황색포인터와 스왑을하고 주황색 포인터를 한 칸 이동시켜야한다.

그래서 분홍색과 초록색 포인터가 만나게 될 것이고, 한 번 더 스왑하고, 분홍색 포인터가 초록색 포인터의 위치를 역전하기에, 종료될 수 있게 되지.

void sortColors(int[] nums)
{
	int idx0 = 0;
	int idx2 = nums.length - 1;
	int i = 0;
	while(i <= idx2) //index가 초록색 index보다 작거나 같을 때 계속해서 swap을 할 수 있겠지.
	{
		if(nums[i] == 0)
		{
			swap(nums[i], nums[idx0]);
			idx0++;
			i++;
		}
		else if(nums[i] == 2)
		{
			swap(nums[i], nums[idx2]);
			idx2—;
		}
		else // nums[i] == 1
		{
			i++
		}
	} 
}



in-place Swap?
두 개의 변수 또는 값 사이의 위치를 교환하는 작업
일반적으로 프로그래밍에서 변수를 교환하려면 추가적인 변수가 필요하지만, “in-place swap”은 임시 변수를 사용하지 않고도 교환이 가능하게 한다.

예를 들어
A = A + B
B = A - B
A = A - B


------------------------------------------------------------------------------------------
for루프를 통해서 탐색하는건 1차원으로 해결한다.
고정된 다중 Idx는 for루프 바깥에 선언해서, 탐색하는 과정에서 우리가 설정한 특정 조건에 맞으면 그 조건에 맞는 연산을 하고, 고정된 Idx를 바꾸면 된다.

그래서 탐색하는 것은 for문으로 진행하되, 어떤 동작은 if문이라는 조건문을 통해서 진행하면 된다.
