정렬이된 Array에서의 search
-> binary Search (log(n))
정렬이 되지 않은 Array에서의 search

두 개의 정렬된 Array를 합쳐서 하나의 정렬된 array로 만드는 방법.

새로운 Array를 만들어서 정렬을 해달라는 상당히 쉬워
두 개의 인덱스를 가지고 작은 숫자를 하나씩 넣어주면 완성이 되는거지.
 
만약 기존에 있는 Array에 정렬을 해야한다면 어떨까?
[1, 3, 4, 0, 0, 0] 이런식으로 0은 숫자를 채우기 위해서 만들어 놓은 공간이라고 칠때, 
0을 첫 번째 부분부터 순차적으로 밀어버리고, 그리고 유효한 숫자가 있는 인덱스부터 다른 배열의 인덱스의 값과 비교를 통해서 작은 숫자를 0번부터 채워넣는 방법을 사용하면 해결할 수 있겠지.

그런데, 여기서 의문이 들어. 굳이 저렇게 한 번 0을 다 이동시키고 진행해야하나?

포인터를 가장 큰 수부터 보게한 다음, 0을 가장 큰 위치에 이동시키게 만들면 되지 않을까?

이를 위해서 포인터를 잘 만들고 그걸 잘 이용하는게 필요할 것 같다.

void merge(int[] nums1, int m, int[] nums2, int n)
{
	int num1Idx = m-1;
	int num2Idx = n-1;
	int wIdx = nums1.length - 1;

	if (num2Idx < 0)
	{
		return;
	}
	while (0 <= num1Idx && 0 <= num2Idx)
	{
		int num1 = nums1[num1Idx];
		int num2 = nums2[num2Idx];
		if (num2 <= num1)
		{
			int num = num1;
			num1[wIdx] = num;
			numIdx—;
			wIdx—;
		}
		else
		{
			int num = num2;
			num1[wIdx] = num;
			num2Idx—;
			wIdx—;
		}
	}
	while (0 <= num2Idx)
	{
		nums1[wIdx] = nums2[num2Idx];
		nums2Idx—;
		wIdx—;
	}

}

-----------------------------------------------------------------------------
가장 중요한 핵심은 인덱스를 가지고 접근하는 사고방식이 중요하다.
Writing Index, Reading Index 
인덱스를 어떻게 활용해야하는가에 대해서 이해를 한다면, 기초적인 Array 문제는 다 해결이 가능하다.

배열이 있으면, 특정 위치에서 비교를하고 스왑을 하던 비워진 칸을 채우던 그 과정은 어느 위치에서 진행되는지 필요하고 이는 index를 어떻게 활용하는가가 중요하기에 
인덱스를 어떻게 사용할지에대해서 생각해보는게 중요하다.
단순히 순회를 한다. 이렇게 용도를 잡으면 할게 없지.

순회를 하는데 그 순회의 목적이 비교를 위한 것인가? 아니면 쓰기를 위한 것인가? 이런 과정이 필요하다. 
그리고 너무 당연하게도, 이러한 인덱스를 활용한 Pointer 기능은 하나로만 이루어져야한다는 것은 없다.
multi Pointer를 활용하는것이 필요하다면 사용하는 것이다.
-----------------------------------------------------------------------------


