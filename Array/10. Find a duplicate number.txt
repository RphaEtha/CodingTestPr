Find a duplicate number

순차적으로 비어있지 않고 원소를 갖는 배열이 존재한다고 가정하고, 중복된 값을 찾아내는 문제.

[1, 2, 3, 4, 2]
이와 같이 1~4의 원소를 가지지만, 중복된 값을 가지고 있는 배열에서 중복된 값을 찾아내는 문제지.

가장 단순무식하게 bruteForce 방식으로는
multiPointer와 이중 for문을 활용해서, 두 개의 인덱스가 가리키는 값이 같은 경우를 찾아내면 돼.
그러나, 이는 O(n^2)으로 너무 느려
————————————————————————————————————————————————
그럴땐, sorting을 먼저 해서 해결해보는 방법도 있지.
그래서 정렬한 후 두개의 pointer를 만들어서 두개의 인접한 두 쌍의 값이 동일한지를 보면 돼. 
그러면 정렬하는데 필요한 nlogn과 비교하는데 필요한 n이 더해져서 O(nlogn)이 돼.
조금더 빠르게는 어떻게 할까?
————————————————————————————————————————————————
우리가 새로운 Array를 만들어서 count를 하면 돼.
여기서 숫자의 값과 index를 일치시켜서 count를 하면 되겠지.

이 경우 O(n)의 시간복잡도로 해결했지만, O(n)의 공간복잡도가 발생했지.

O(n)의 공간복잡도를 O(1)로 줄여달라할 수 있겠지.
————————————————————————————————————————————————

우리가 저 공간을 어떤 용도로 사용했는지를 보면 다른 방법으로도 전환이 가능할 수 있다.
우리는 저 공간에 count를 통해서 값이 있다는 것을 마킹을 했었다. 똑같은 마킹 방법을 사용하면서 추가적으로 space를 받지 않고 해결하는 방법이 있어.

저 array를 그대로 적용하는거야.
내부적으로 어떤 숫자를 만났다는 것을 -1을 곱해서 마킹을 해주는거야.
(그 방법 자체는 트릭으로 보이지만, 이 Array의 값 숫자 자체를 Array의 index로 쓴다는 사고방식이 매우 중요하다.)

[말하고자 하는 부분]
Array의 element들을 index로 보는 관점을 사용했어. 
이러한 관점은 배열을 다른 방법으로도 볼 수 있게도 만들어주기에 좋은 관점이다.

한 번 접근했던 공간에 -를 붙여줌으러써 marking을 해준 것. (문제 풀이를 위한 트릭이긴하다. 이런 테크닉이 있다는 것을 알고 있는 것도 중요할 수 있다.)
